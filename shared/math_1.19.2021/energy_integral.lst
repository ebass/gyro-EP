%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /global/u2/b/bassem/gyro-EP/shared/math/energy_integral.f90
Compiled : 01/19/21  14:38:37
Compiler : Version 9.1.0
Ftnlx    : Version 9.1.0 
Target   : x86-64
Command  : ftn_driver.exe -hcpu=haswell -hdynamic -D__CRAYXC -D__CRAY_HASWELL
           -D__CRAYXT_COMPUTE_LINUX_TARGET -hnetwork=aries -hnoomp -em
           -J/global/homes/b/bassem/gyro-EP/modules -sreal64 -eD -Ktrap=fp -m1
           -Rbcdps -c energy_integral.f90
           -I/opt/cray/pe/cce/9.1.0/cce-clang/x86_64/lib/clang/9.0.0/include
           -I/opt/cray/pe/cce/9.1.0/cce/x86_64/include/craylibs -I/usr/include
           -I/usr/include -I/opt/cray/pe/fftw/3.3.8.4/haswell/include
           -I/opt/cray/pe/libsci/19.06.1/CRAY/9.0/x86_64/include
           -I/opt/cray/pe/mpt/7.7.10/gni/mpich-cray/9.0/include
           -I/opt/cray/pe/hdf5/1.10.5.2/cray/9.0/include
           -I/opt/cray/pe/netcdf/4.6.3.2/cray/9.0/include
           -I/opt/cray/rca/2.2.20-7.0.1.1_4.53__g8e3fb5b.ari/include
           -I/opt/cray/alps/6.6.58-7.0.1.1_6.10__g437d88db.ari/include
           -I/opt/cray/xpmem/2.2.20-7.0.1.1_4.14__g0475745.ari/include
           -I/opt/cray/gni-headers/5.0.12.0-7.0.1.1_6.32__g3b1768f.ari/include
           -I/opt/cray/dmapp/7.1.1-7.0.1.1_4.54__g38cf134.ari/include
           -I/opt/cray/pe/pmi/5.0.14/include
           -I/opt/cray/ugni/6.0.14.0-7.0.1.1_7.40__ge78e5b0.ari/include
           -I/opt/cray/udreg/2.3.2-7.0.1.1_3.38__g8175d3d.ari/include
           -I/opt/cray/wlm_detect/1.3.3-7.0.1.1_4.16__g7109084.ari/include
           -I/opt/cray/krca/2.2.6-7.0.1.1_5.39__gb641b12.ari/include
           -I/opt/cray-hss-devel/9.0.0/include
Program
  Units  : ENERGY_INTEGRAL

ftnlx report
------------
Source   : /global/u2/b/bassem/gyro-EP/shared/math/energy_integral.f90
Date     : 01/19/2021  14:38:37


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    1.    !---------------------------------------------------------
    2.    ! energy_integral.f90
    3.    !
    4.    ! PURPOSE:
    5.    !  Construct energy grid and integration weights.
    6.    !
    7.    ! NOTES:
    8.    !  For one energy gridpoint, the rule is trivial.
    9.    !
   10.    ! FOR MAXWELLIAN DISTRIBUTIONS:
   11.    !
   12.    !  For n_energy > 1, we break the integration into
   13.    !  two regions: 
   14.    !
   15.    !  region 1: (0,energy_max)
   16.    !  region 2: (energy_max,inf)
   17.    !
   18.    !  Region 1:
   19.    !  --------
   20.    !
   21.    !  To do the region 1 integral, we change variable to s, 
   22.    !  where:
   23.    !                          x
   24.    !                   2      /          -t
   25.    !        s(x) = --------   | sqrt(t) e   dt
   26.    !               sqrt(pi)   /
   27.    !                          0
   28.    !
   29.    !  Clearly, s(inf) = 2/sqrt(pi) * Gamma(3/2) = 1.0
   30.    !
   31.    !  s(x) = P(3/2,x)  [p. 262, Abramowitz and Stegun]
   32.    !
   33.    !  P(3/2,x) = P(1/2,x) - sqrt(x) exp(-x) / Gamma(3/2)
   34.    !  P(1/2,x) = Erf(sqrt(x))
   35.    !
   36.    !  We use Gauss-Legendre weights on (0,s(energy_max)) to 
   37.    !  generate n_energy-1 points:
   38.    !
   39.    !     "call GaussLegendre(0.0,s0,sn,wn,n_energy-1)"
   40.    ! 
   41.    !  Then, we invert s(energy(i)) = sn(i) for the 
   42.    !  abscissae energy(i).
   43.    !
   44.    !
   45.    !  Region 2:
   46.    !  --------
   47.    !
   48.    !  Method 1:
   49.    !
   50.    !   The region 2 integral (which ought to be exponentially
   51.    !   small) is done with one weight at position 
   52.    !
   53.    !            energy(n_energy) = energy_max.
   54.    !
   55.    !   The weight is just 1-s0.
   56.    !
   57.    ! FOR SLOWING DOWN DISTRIBUTIONS:
   58.    !
   59.    !  With energy normalized to the birth energy,
   60.    !  the normalized distribution function takes the form
   61.    !
   62.    !                       3                    eps^(1/2)
   63.    !  f(eps) = -------------------------  ---------------------- Theta(1-eps)
   64.    !           2 ln[(1+eps_c^3)/eps_c^3]   eps_c^(3/2)+eps^(3/2)
   65.    !
   66.    !  With eps_c the "crossover energy" (velocity at which electron and ion
   67.    !  collisions contribute equally to slowing down) normalized to the birth
   68.    !  energy and Theta indicating the standard step function.
   69.    !
   70.    !  The crossover energy is a function of radius. We choose the
   71.    !  energy grid values to be independent of radius, satisfying
   72.    !  the condition that each bin is of equal weight at the
   73.    !  reference radius. The grid energy value falls simply
   74.    !  in the center of the bin.
   75.    !
   76.    !  The integral over a region (a,b) has the analytic solution:
   77.    !
   78.    !    /b                          1             [  eps_c^(3/2)+b^(3/2) ]
   79.    !    | f(eps) d eps = ---------------------- ln|----------------------|
   80.    !    /a              ln[(1+eps_c^3)/eps_c^3]   [  eps_c^(3/2)+a^(3/2) ]
   81.    !
   82.    !  A region (a,b) has integral weight equal to (1/n) times the total
   83.    !  when b is given by:
   84.    !
   85.    !    b = [(eps_c^(3/2)+a^(3/2))*((eps_c^(3/2)+1)/eps_c^(3/2))^(1/n)-eps_c^(3/2)]^(2/3)
   86.    !
   87.    !------------------------------------------------------------------------
   88.    
   89.    
   90.    
   91.    subroutine energy_integral(n_energy,energy_max,n_kinetic,n_x,ir_norm,energy,w_energy,velocity_dist_method_vec,energy_c)
   92.    
   93.      use math_constants
   94.    
   95.      !------------------------------------------
   96.      implicit none
   97.      !
   98.      integer, intent(in) :: n_energy
   99.      integer, intent(in) :: n_kinetic
  100.      integer, intent(in) :: n_x
  101.      integer, intent(in) :: ir_norm
  102.      real, intent(in) :: energy_max(n_kinetic)
  103.      integer, intent(in) :: velocity_dist_method_vec(5)
  104.      real, intent(in) :: energy_c(n_kinetic,n_x)
  105.      ! 
  106.      real, intent(inout) :: energy(n_energy,n_kinetic)
  107.      real, intent(inout) :: w_energy(n_energy,n_kinetic,n_x)
  108.      !
  109.      integer :: i
  110.      integer :: is
  111.      integer :: ix
  112.      !
  113.      real :: s_max
  114.      real :: s1
  115.      real :: d_e
  116.      real :: ec32
  117.      real :: a
  118.      real :: b
  119.      !
  120.      real, dimension(:), allocatable :: sn
  121.      real, dimension(:), allocatable :: wn
  122.      !
  123.      real, external :: p32
  124.      !------------------------------------------
  125.    
  126.      allocate(sn(n_energy-1))
  127.      allocate(wn(n_energy-1))
  128.    
  129.    
  130.      do is = 1, n_kinetic
  131.    
  132.       select case (velocity_dist_method_vec(is))
  133.    
  134.       case default
  135.    
  136.         d_e = energy_max(is)/n_energy
  137.    
  138.         if (n_energy == 1) then
  139.    
  140.            energy(1,is)   = energy_max(is)
  141.            w_energy(1,is,:) = 1.0
ftn-6263 ftn: VECTOR ENERGY_INTEGRAL, File = energy_integral.f90, Line = 141 
  A loop starting at line 141 was not vectorized because it contains a reference to a non-vector intrinsic on line 141.

  142.    
  143.         else 
  144.    
  145.            ! p32(x) == P(3/2,x)
  146.    
  147.            s_max = p32(energy_max(is))
  148.            s1 = 1.0-s_max
  149.    
  150.            call gauss_legendre(0.0,s_max,sn,wn,n_energy-1)
  151.    
  152.            ! Map abscissae to energy:
  153.    
  154.            do i=1,n_energy-1
  155.               w_energy(i,is,:) = wn(i)
ftn-6263 ftn: VECTOR ENERGY_INTEGRAL, File = energy_integral.f90, Line = 155 
  A loop starting at line 155 was not vectorized because it contains a reference to a non-vector intrinsic on line 155.

  156.               call invert_p32(sn(i),energy(i,is),energy_max(is))
  157.            enddo
  158.    
  159.            ! Add remainder
  160.    
  161.            energy(n_energy,is) = energy_max(is)
  162.    
  163.            w_energy(n_energy,is,:) = s1 
ftn-6263 ftn: VECTOR ENERGY_INTEGRAL, File = energy_integral.f90, Line = 163 
  A loop starting at line 163 was not vectorized because it contains a reference to a non-vector intrinsic on line 163.

  164.    
  165.         endif
  166.    
  167.       case(2)   ! Slowing down distribution
  168.    
  169.    !!!fixed    energy_max(is) = 1.
  170.        a = 0.
  171.        do i = 1, n_energy
  172.          ec32 = (energy_c(is,ir_norm))**1.5
  173.          b = ( (ec32+a**1.5)*((ec32+1.)/ec32)**(1./n_energy) - ec32)**(2./3.)
  174.          energy(i,is) = 0.5*(b+a)
  175.    !      print *, energy_c(ir_norm), ec32, a, b
  176.          do ix = 1, n_x
  177.            ec32 = (energy_c(is,ix))**1.5
  178.            w_energy(i,is,ix) = log((ec32+b**1.5)/(ec32+a**1.5)) / &
  179.                                  log((ec32+1.)/ec32)
  180.    !        if (ISNAN(w_energy(i,is,ix)) .or. (w_energy(i,is,ix)==0.0) ) print *, 'in energy_integral', i, ix, w_energy(i,is,ix), a, b, energy_c(is,ix)
  181.          enddo ! Radius loop, ix
  182.          a = b
  183.        enddo ! Energy loop, i
  184.    
  185.       end select ! Distribution function method 
  186.    
  187.      enddo  ! Kinetic species loop
  188.    
  189.      deallocate(sn)
  190.      deallocate(wn)
  191.    
  192.    end subroutine energy_integral
ftn-5001 ftn: NOTE ENERGY_INTEGRAL, File = energy_integral.f90, Line = 192 
  Local variable "D_E" is assigned a value but never used.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                         E x t e r n a l   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Name  Messages
----  --------
ENERGY_INTEGRAL
      Defined as:  Subroutine (line 91, file energy_integral.f90)

      Interface:   None

      Calls:       P32 (Line 147, file energy_integral.f90)
                   GAUSS_LEGENDRE (Line 150, file energy_integral.f90)
                   INVERT_P32 (Line 156, file energy_integral.f90)
                   LOG(Intrinsic) (Line 178, file energy_integral.f90)
                   LOG(Intrinsic) (Line 179, file energy_integral.f90)

        Uses:      MATH_CONSTANTS

Name  Messages
----  --------
GAUSS_LEGENDRE
      Defined as:  No definitions.

      Interface:   None

      Called By:   ENERGY_INTEGRAL (Line 150, file energy_integral.f90)

Name  Messages
----  --------
INVERT_P32
      Defined as:  No definitions.

      Interface:   None

      Called By:   ENERGY_INTEGRAL (Line 156, file energy_integral.f90)

Name  Messages
----  --------
LOG(Intrinsic)
      Defined as:  No definitions.

      Interface:   None

      Called By:   ENERGY_INTEGRAL (Line 178, file energy_integral.f90)
                   ENERGY_INTEGRAL (Line 179, file energy_integral.f90)

Name  Messages
----  --------
MATH_CONSTANTS
      Defined as:  No definitions.

      Used By:     ENERGY_INTEGRAL

Name  Messages
----  --------
P32
      Defined as:  No definitions.

      Interface:   None

      Called By:   ENERGY_INTEGRAL (Line 147, file energy_integral.f90)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
